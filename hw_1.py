# -*- coding: utf-8 -*-
"""Ð”Ð—1_ÐšÑ€Ð°Ð²Ñ‡ÐµÐ½ÐºÐ¾ Ð¡ÐµÑ€Ð³Ñ–Ð¹ Ð¡ÐµÑ€Ð³Ñ–Ð¹Ð¾Ð²Ð¸Ñ‡.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G0lBmRnHLMpF1HYY_OWvNecC6NvgiB_c

# ÐÐ°Ð³Ð°Ð´ÑƒÐ²Ð°Ð½Ð½Ñ Ð¿Ð¾ Markdown

ÐÐ°Ð´Ð°Ñ”Ð¼Ð¾ Ð½ÐµÐ²ÐµÐ»Ð¸ÐºÐµ Ð½Ð°Ð³Ð°Ð´ÑƒÐ²Ð°Ð½Ð½Ñ Ð·Ð°Ð¿Ð¸ÑÑ–Ð² Ð²
[Markdown](https://colab.research.google.com/notebooks/markdown_guide.ipynb) (LaTeX):

Markdown | Preview
--- | ---
`**bold text**` | **bold text**
 \\$\frac{x}{y}\\$ | $\frac{x}{y}$
 \\$p^{x}_{y}\\$ | $p^{x}_{y}$
\\$x \cdot y\\$ | $x \cdot y$
\\$\sqrt{x}\\$ | $\sqrt{x}$
\\$\pi\\$ | $\pi$
\\$\approx\\$ | $\approx$

Ð† Ñ‰Ðµ Ð´ÐµÐºÑ–Ð»ÑŒÐºÐ° Ð¿Ñ€Ð¸ÐºÐ»Ð°Ð´Ñ–Ð²:

```markdown
$y=x^2$

$e^{i\pi} + 1 = 0$

$e^x=\sum_{i=0}^\infty \frac{1}{i!}x^i$

$\frac{n!}{k!(n-k)!} = {n \choose k}$

$A_{m,n} =
 \begin{pmatrix}
  a_{1,1} & a_{1,2} & \cdots & a_{1,n} \\
  a_{2,1} & a_{2,2} & \cdots & a_{2,n} \\
  \vdots  & \vdots  & \ddots & \vdots  \\
  a_{m,1} & a_{m,2} & \cdots & a_{m,n}
 \end{pmatrix}$

 $$
 I =
 \left (\begin{array}{cc}
 1 & 0\\
 0 & 1
 \end{array}\right)
 $$
```

$y=x^2$

$e^{i\pi} + 1 = 0$

$e^x=\sum_{i=0}^\infty \frac{1}{i!}x^i$

$\frac{n!}{k!(n-k)!} = {n \choose k}$

$A_{m,n} =
 \begin{pmatrix}
  a_{1,1} & a_{1,2} & \cdots & a_{1,n} \\
  a_{2,1} & a_{2,2} & \cdots & a_{2,n} \\
  \vdots  & \vdots  & \ddots & \vdots  \\
  a_{m,1} & a_{m,2} & \cdots & a_{m,n}
 \end{pmatrix}$

$I =
\left (\begin{array}{cc}
1 & 0\\
0 & 1
\end{array}\right)$
 ---

# Ð—Ð°Ð²Ð´Ð°Ð½Ð½Ñ 1.
Ð’ ÑˆÐ°Ð±Ð»Ð¾Ð½Ñ– Ð½Ð°Ð²ÐµÐ´ÐµÐ½Ñ– Ñ‡Ð¸ÑÐ»Ð¾Ð²Ñ– Ð²ÐµÐºÑ‚Ð¾Ñ€Ð¸ $\overline{a}$ Ñ‚Ð° $\overline{b}$. ÐŸÐ¾Ñ€Ð°Ñ…ÑƒÐ¹ Ð½Ð°ÑÑ‚ÑƒÐ¿Ð½Ðµ:
- ÑÑƒÐ¼Ð° $\overline{a}$ Ñ‚Ð° $\overline{b}$
- Ñ€Ñ–Ð·Ð½Ð¸Ñ†Ñ $\overline{a}$ Ñ‚Ð° $\overline{b}$
- ÑÑƒÐ¼Ð° $\overline{a}$ Ñ‚Ð° $\overline{b}^T$. ÐŸÐ¾ÑÑÐ½Ð¸ Ð¾Ñ‚Ñ€Ð¸Ð¼Ð°Ð½Ð¸Ð¹ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚.
- Ð¼Ð°Ñ‚Ñ€Ð¸Ñ‡Ð½Ð¸Ð¹ Ð´Ð¾Ð±ÑƒÑ‚Ð¾Ðº (dot product) $\overline{a}$ Ñ‚Ð° $\overline{b}^T$.
- Ð¼Ð°Ñ‚Ñ€Ð¸Ñ‡Ð½Ð¸Ð¹ Ð´Ð¾Ð±ÑƒÑ‚Ð¾Ðº (dot product) $\overline{a}$ Ñ‚Ð° $\overline{b}$. ÐŸÐ¾ÑÑÐ½Ð¸ Ð¾Ñ‚Ñ€Ð¸Ð¼Ð°Ð½Ð¸Ð¹ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚.
- Ð´Ð¾Ð±ÑƒÑ‚Ð¾Ðº ÐÐ´Ð°Ð¼Ð°Ñ€Ð° (Hadamard product) $\overline{a}$ Ñ‚Ð° $\overline{b}$. ÐŸÐ¾ÑÑÐ½Ð¸ Ð¾Ñ‚Ñ€Ð¸Ð¼Ð°Ð½Ð¸Ð¹ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚.
- Ð´Ñ–Ð»ÐµÐ½Ð½Ñ $\overline{a}$ Ñ‚Ð° $\overline{b}$. ÐŸÐ¾ÑÑÐ½Ð¸ Ð¾Ñ‚Ñ€Ð¸Ð¼Ð°Ð½Ð¸Ð¹ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚.
- Ð´Ñ–Ð»ÐµÐ½Ð½Ñ $\overline{a}$ Ñ‚Ð° $\overline{b}^T$. ÐŸÐ¾ÑÑÐ½Ð¸ Ð¾Ñ‚Ñ€Ð¸Ð¼Ð°Ð½Ð¸Ð¹ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚.
"""

import numpy as np
# ÐšÐ¾Ð´ Ð¾Ð³Ð¾Ð»Ð¾ÑˆÐµÐ½Ð½Ñ Ð²ÐµÐºÑ‚Ð¾Ñ€Ñ–Ð² Ð½Ðµ Ð¼Ð¾Ð¶Ð½Ð° Ð·Ð¼Ñ–Ð½ÑŽÐ²Ð°Ñ‚Ð¸
a = np.array([[1, 2, 3, 4, 5]])
b = np.array([[1/2, 1, 2, 3, 4]])

res = (a + b)
res

res = a - b
res

#b Ñ” Ð¾Ð´Ð½Ð¾Ñ€ÑÐ´ÐºÐ¾Ð²Ð¸Ð¼ Ð¼Ð°ÑÐ¸Ð²Ð¾Ð¼ Ð· Ñ„Ð¾Ñ€Ð¼Ð¾ÑŽ ( (1, 5) ), Ñ‚Ð¾Ð±Ñ‚Ð¾ Ð² Ð½ÑŒÐ¾Ð¼Ñƒ Ñ” Ð¾Ð´Ð¸Ð½ Ñ€ÑÐ´Ð¾Ðº Ñ– Ð¿'ÑÑ‚ÑŒ ÑÑ‚Ð¾Ð²Ð¿Ñ†Ñ–Ð². ÐšÐ¾Ð»Ð¸ Ñ‚Ñ€Ð°Ð½ÑÐ¿Ð¾Ð½ÑƒÑŽ b Ð·Ð° Ð´Ð¾Ð¿Ð¾Ð¼Ð¾Ð³Ð¾ÑŽ b.T, Ñ‚Ð¾ Ð¾Ñ‚Ñ€Ð¸Ð¼ÑƒÑŽ Ð²ÐµÐºÑ‚Ð¾Ñ€-ÑÑ‚Ð¾Ð²Ð¿ÐµÑ†ÑŒ Ð· Ñ„Ð¾Ñ€Ð¼Ð¾ÑŽ ( (5, 1) ), Ñ– ÐµÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¸ Ð±ÑƒÐ´ÑƒÑ‚ÑŒ Ñ€Ð¾Ð·Ð¼Ñ–Ñ‰ÐµÐ½Ñ– Ð²ÐµÑ€Ñ‚Ð¸ÐºÐ°Ð»ÑŒÐ½Ð¾.
res = a + b.T
res

#
res = np.dot(a, b.T)
res

# ÐŸÐ¾ÑÑÐ½ÐµÐ½Ð½Ñ:  Ñ—Ñ… Ð½Ðµ Ð¼Ð¾Ð¶Ð½Ð° Ð±ÐµÐ·Ð¿Ð¾ÑÐµÑ€ÐµÐ´Ð½ÑŒÐ¾ Ð¿ÐµÑ€ÐµÐ¼Ð½Ð¾Ð¶Ð¸Ñ‚Ð¸ Ð¼ÐµÑ‚Ð¾Ð´Ð¾Ð¼ np.dot, Ð¾ÑÐºÑ–Ð»ÑŒÐºÐ¸ Ð´Ð»Ñ Ñ‚Ð°ÐºÐ¾Ð³Ð¾ Ð¼Ð½Ð¾Ð¶ÐµÐ½Ð½Ñ:ÐºÑ–Ð»ÑŒÐºÑ–ÑÑ‚ÑŒ ÑÑ‚Ð¾Ð²Ð¿Ñ†Ñ–Ð² Ñƒ a (5) Ð¿Ð¾Ð²Ð¸Ð½Ð½Ð° Ð´Ð¾Ñ€Ñ–Ð²Ð½ÑŽÐ²Ð°Ñ‚Ð¸ ÐºÑ–Ð»ÑŒÐºÐ¾ÑÑ‚Ñ– Ñ€ÑÐ´ÐºÑ–Ð² Ñƒ b (Ð°Ð»Ðµ Ñƒ b Ñ—Ñ… Ñ‚ÐµÐ¶ 5, Ð° Ð½Ðµ 1, ÑÐº Ð¿Ð¾Ñ‚Ñ€Ñ–Ð±Ð½Ð¾). OÐ±Ð¸Ð´Ð²Ð° Ð²ÐµÐºÑ‚Ð¾Ñ€Ð¸ Ð¿Ð¾Ñ‚Ñ€Ñ–Ð±Ð½Ð¾ Ð·Ñ€Ð¾Ð±Ð¸Ñ‚Ð¸ Ð¾Ð´Ð½Ð¾Ð¼Ñ–Ñ€Ð½Ð¸Ð¼Ð¸ Ð°Ð±Ð¾ Ð¾Ð´Ð¸Ð½ Ð· Ð½Ð¸Ñ… Ñ‚Ñ€Ð°Ð½ÑÐ¿Ð¾Ð½ÑƒÐ²Ð°Ñ‚Ð¸
res = np.dot(a,b)
res

# ÐŸÐ¾ÑÑÐ½ÐµÐ½Ð½Ñ: Ð”Ð¾Ð±ÑƒÑ‚Ð¾Ðº ÐÐ´Ð°Ð¼Ð°Ñ€Ð° Ð¿ÐµÑ€ÐµÐ´Ð±Ð°Ñ‡Ð°Ñ” Ð¿Ð¾ÐµÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð½Ðµ Ð¼Ð½Ð¾Ð¶ÐµÐ½Ð½Ñ Ð²Ñ–Ð´Ð¿Ð¾Ð²Ñ–Ð´Ð½Ð¸Ñ… ÐµÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ–Ð² Ð´Ð²Ð¾Ñ… Ð²ÐµÐºÑ‚Ð¾Ñ€Ñ–Ð².
res = a * b
res

# ÐŸÐ¾ÑÑÐ½ÐµÐ½Ð½Ñ: ÐŸÐ¾ÐµÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð½Ðµ Ð´Ñ–Ð»ÐµÐ½Ð½Ñ Ð²ÐµÐºÑ‚Ð¾Ñ€Ð° a Ð½Ð° Ð²ÐµÐºÑ‚Ð¾Ñ€ b Ð´Ð°Ñ” Ð½Ð¾Ð²Ð¸Ð¹ Ð²ÐµÐºÑ‚Ð¾Ñ€, Ð´Ðµ ÐºÐ¾Ð¶ÐµÐ½ ÐµÐ»ÐµÐ¼ÐµÐ½Ñ‚ Ñ” Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð¾Ð¼ Ð´Ñ–Ð»ÐµÐ½Ð½Ñ Ð²Ñ–Ð´Ð¿Ð¾Ð²Ñ–Ð´Ð½Ð¸Ñ… ÐµÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ–Ð² a Ñ‚Ð° b.
res = a / b
res

# ÐŸÐ¾ÑÑÐ½ÐµÐ½Ð½Ñ: Ð’ÐµÐºÑ‚Ð¾Ñ€Ð¸ a (Ñ€Ð¾Ð·Ð¼Ñ–Ñ€Ð¾Ð¼ 1x5) Ñ‚Ð° b (Ñ€Ð¾Ð·Ð¼Ñ–Ñ€Ð¾Ð¼ 1x5). Ð¢Ñ€Ð°Ð½ÑÐ¿Ð¾Ð½ÑƒÐ²Ð°Ð½Ð½Ñ Ð²ÐµÐºÑ‚Ð¾Ñ€Ð° Ð¿ÐµÑ€ÐµÑ‚Ð²Ð¾Ñ€ÑŽÑ” Ð¹Ð¾Ð³Ð¾ Ð² Ð²ÐµÐºÑ‚Ð¾Ñ€-ÑÑ‚Ð¾Ð²Ð¿ÐµÑ†ÑŒ ð‘ð‘‡ (Ñ€Ð¾Ð·Ð¼Ñ–Ñ€Ð¾Ð¼ 5x1). Ð Ð¿Ð¾Ñ‚Ñ–Ð¼ Ð²Ð¸ÐºÐ¾Ð½ÑƒÑ”Ð¼Ð¾ Ð´Ñ–Ð»ÐµÐ½Ð½Ñ.
res = a / b_T
res

"""# Ð—Ð°Ð²Ð´Ð°Ð½Ð½Ñ 2
Ð’ Ñ†ÑŒÐ¾Ð¼Ñƒ Ð·Ð°Ð²Ð´Ð°Ð½Ð½Ñ– Ñ‚Ð¸ Ð½Ð°Ð²Ñ‡Ð¸ÑˆÑÑ Ð¿ÐµÑ€ÐµÑ‚Ð²Ð¾Ñ€ÑŽÐ²Ð°Ñ‚Ð¸ Ð²ÐµÐºÑ‚Ð¾Ñ€Ð¸ Ð·Ð° Ð´Ð¾Ð¿Ð¾Ð¼Ð¾Ð³Ð¾ÑŽ Ð°Ñ„Ñ–Ð½Ð½Ð¸Ñ… Ð¿ÐµÑ€ÐµÑ‚Ð²Ð¾Ñ€ÐµÐ½ÑŒ.  
Ð”Ð°Ð½Ð¾ Ð²ÐµÐºÑ‚Ð¾Ñ€:
$$
x =
\left(\begin{array}{cc}
2\\
1
\end{array}\right)
$$


Ð’Ð¸ÐºÐ¾Ð½Ð°Ð¹ Ð°Ð½Ð°Ð»Ñ–Ñ‚Ð¸Ñ‡Ð½Ð¾ Ð½Ð°ÑÑ‚ÑƒÐ¿Ð½Ñ– Ð·Ð°Ð²Ð´Ð°Ð½Ð½Ñ Ð·Ð°Ð´Ð°Ð²ÑˆÐ¸ Ð¼Ð°Ñ‚Ñ€Ð¸Ñ†ÑŽ Ð¿ÐµÑ€ÐµÑ‚Ð²Ð¾Ñ€ÐµÐ½Ð½Ñ Ñ‚Ð° Ð·Ð°ÑÑ‚Ð¾ÑÑƒÐ¹ Ñ—Ñ— Ð´Ð¾ Ð²ÐµÐºÑ‚Ð¾Ñ€Ð° $x$:

1. Ð—Ð¼ÐµÐ½ÑˆÐ¸ Ð²ÐµÐºÑ‚Ð¾Ñ€ $x$ Ð² 2 Ñ€Ð°Ð·Ð¸ Ð¿Ð¾ Ð²Ñ–ÑÑ– $OX$ Ñ‚Ð° Ð·Ð±Ñ–Ð»ÑŒÑˆ Ð² 3 Ñ€Ð°Ð·Ð¸ Ð¿Ð¾ Ð²Ñ–ÑÑ– $OY$.
2. Ð’Ñ–Ð´Ð¾Ð±Ñ€Ð°Ð·Ð¸ Ð²ÐµÐºÑ‚Ð¾Ñ€ $x$ Ð²Ñ–Ð´Ð½Ð¾ÑÐ½Ð¾ Ð¿Ð¾Ñ‡Ð°Ñ‚ÐºÑƒ ÐºÐ¾Ð¾Ñ€Ð´Ð¸Ð½Ð°Ñ‚.
3. ÐŸÐµÑ€ÐµÐ½ÐµÑÐ¸ Ð²ÐµÐºÑ‚Ð¾Ñ€ $x$ Ð½Ð° -3 Ð¿Ð¾ Ð²Ñ–ÑÑ– $OX$ Ñ‚Ð° Ð½Ð° 1 Ð¿Ð¾ Ð²Ñ–ÑÑ– $OY$.
4. Ð—Ð¼Ñ–ÑÑ‚Ð¸ Ð²ÐµÐºÑ‚Ð¾Ñ€ $x$ Ð½Ð° 60Â° Ð¿Ð¾ Ð²Ñ–ÑÑ– $OY$.
5. ÐŸÐ¾Ð²ÐµÑ€Ð½Ð¸ Ð²ÐµÐºÑ‚Ð¾Ñ€ $x$ Ð½Ð° 30Â°.
6. ÐžÐ±'Ñ”Ð´Ð½Ð°Ð¹ Ð¿ÐµÑ€ÐµÑ‚Ð²Ð¾Ñ€ÐµÐ½Ð½Ñ Ð· ÐºÑ€Ð¾ÐºÑ–Ð² 1, 2, 4, 5 Ð² Ð¾Ð´Ð½Ñƒ Ð¼Ð°Ñ‚Ñ€Ð¸Ñ†ÑŽ Ñ‚Ð° Ð·Ð°ÑÑ‚Ð¾ÑÑƒÐ¹ Ñ—Ñ— Ð´Ð¾ Ð²ÐµÐºÑ‚Ð¾Ñ€Ñƒ $x$.

#### 2.1 Ð—Ð¼ÐµÐ½ÑˆÐ¸ Ð²ÐµÐºÑ‚Ð¾Ñ€  $x$  Ð² 2 Ñ€Ð°Ð·Ð¸ Ð¿Ð¾ Ð²Ñ–ÑÑ–  OX  Ñ‚Ð° Ð·Ð±Ñ–Ð»ÑŒÑˆ Ð² 3 Ñ€Ð°Ð·Ð¸ Ð¿Ð¾ Ð²Ñ–ÑÑ–  OY .

$$
M_1 =
\left (\begin{array}{cc}
\frac{1}{2} & 0\\  
0 & 3
\end{array}\right)
$$

$$
M_1x =
\left(\begin{array}{cc}
\frac{1}{2} & 0\\  
0 & 3
\end{array}\right)
\left (\begin{array}{cc}
2\\
1
\end{array}\right)=
\left(\begin{array}{cc}
\frac{1}{2} \cdot 2 + 0 \cdot 1\\
0 \cdot 2 + 3 \cdot 1
\end{array}\right)=
\left(\begin{array}{cc}
1\\
3
\end{array}\right)
$$

#### 2.2 Ð’Ñ–Ð´Ð¾Ð±Ñ€Ð°Ð·Ð¸ Ð²ÐµÐºÑ‚Ð¾Ñ€ $x$ Ð²Ñ–Ð´Ð½Ð¾ÑÐ½Ð¾ Ð¿Ð¾Ñ‡Ð°Ñ‚ÐºÑƒ ÐºÐ¾Ð¾Ñ€Ð´Ð¸Ð½Ð°Ñ‚.

$$
M_2 =
\begin{pmatrix}
-1 & 0 \\
0 & -1
\end{pmatrix}, \quad
M_2 x =
\begin{pmatrix}
-1 & 0 \\
0 & -1
\end{pmatrix}
\begin{pmatrix}
2 \\
1
\end{pmatrix}
=
\begin{pmatrix}
-1 \cdot 2 + 0 \cdot 1 \\
0 \cdot 2 + (-1) \cdot 1
\end{pmatrix}
=
\begin{pmatrix}
-2 \\
-1
\end{pmatrix}
$$

#### 2.3 ÐŸÐµÑ€ÐµÐ½ÐµÑÐ¸ Ð²ÐµÐºÑ‚Ð¾Ñ€ $x$, Ð·Ð°Ð´Ð°Ð²ÑˆÐ¸ Ð²Ñ–Ð´Ð¿Ð¾Ð²Ñ–Ð´Ð½Ñƒ Ð¼Ð°Ñ‚Ñ€Ð¸Ñ†ÑŽ Ñ– Ð¿Ð¾Ð¼Ð½Ð¾Ð¶Ð¸Ð²ÑˆÐ¸ Ð½Ð° Ð½ÐµÑ—,  Ð½Ð° -3 Ð¿Ð¾ Ð²Ñ–ÑÑ– $OX$ Ñ‚Ð° Ð½Ð° 1 Ð¿Ð¾ Ð²Ñ–ÑÑ– $OY$.
"""



"""$$
M_3 =
\begin{pmatrix}
1 & 0 & -3 \\
0 & 1 & 1 \\
0 & 0 & 1
\end{pmatrix}, \quad
x =
\begin{pmatrix}
2 \\
1 \\
1
\end{pmatrix}, \quad
M_3 x =
\begin{pmatrix}
1 & 0 & -3 \\
0 & 1 & 1 \\
0 & 0 & 1
\end{pmatrix}
\begin{pmatrix}
2 \\
1 \\
1
\end{pmatrix}
=
\begin{pmatrix}
1 \cdot 2 + 0 \cdot 1 + (-3) \cdot 1 \\
0 \cdot 2 + 1 \cdot 1 + 1 \cdot 1 \\
0 \cdot 2 + 0 \cdot 1 + 1 \cdot 1
\end{pmatrix}
=
\begin{pmatrix}
-1 \\
2 \\
1
\end{pmatrix}
$$

"""



"""#### 2.4 Ð—Ð¼Ñ–ÑÑ‚Ð¸ Ð²ÐµÐºÑ‚Ð¾Ñ€ $x$ Ð½Ð° 60Â° Ð¿Ð¾ Ð²Ñ–ÑÑ– $OY$.

$$
M_4 =
\begin{pmatrix}
1 & 0 \\
\tan(\theta) & 1
\end{pmatrix}
=
\begin{pmatrix}
1 & 0 \\
\tan\frac{\pi}{3} & 1
\end{pmatrix}
=
\begin{pmatrix}
1 & 0 \\
\sqrt{3} & 1
\end{pmatrix}, \quad
M_4 x =
\begin{pmatrix}
1 & 0 \\
\sqrt{3} & 1
\end{pmatrix}
\cdot
\begin{pmatrix}
2 \\
1
\end{pmatrix}
=
\begin{pmatrix}
1 \cdot 2 + 0 \cdot 1 \\
\sqrt{3} \cdot 2 + 1 \cdot 1
\end{pmatrix}
=
\begin{pmatrix}
2 \\
2 \sqrt{3} + 1
\end{pmatrix}
$$

#### 2.5 ÐŸÐ¾Ð²ÐµÑ€Ð½Ð¸ Ð²ÐµÐºÑ‚Ð¾Ñ€ $x$ Ð½Ð° 30Â°.
"""



"""$$
M_5 =
\begin{pmatrix}
\cos\left(\frac{\pi}{6}\right) & -\sin\left(\frac{\pi}{6}\right) \\
\sin\left(\frac{\pi}{6}\right) & \cos\left(\frac{\pi}{6}\right)
\end{pmatrix}
=
\begin{pmatrix}
\frac{\sqrt{3}}{2} & -\frac{1}{2} \\
\frac{1}{2} & \frac{\sqrt{3}}{2}
\end{pmatrix}, \quad
M_5 x =
\begin{pmatrix}
\frac{\sqrt{3}}{2} & -\frac{1}{2} \\
\frac{1}{2} & \frac{\sqrt{3}}{2}
\end{pmatrix}
\begin{pmatrix}
2 \\
1
\end{pmatrix}
=
\begin{pmatrix}
\frac{\sqrt{3}}{2} \cdot 2 + \left(-\frac{1}{2}\right) \cdot 1 \\
\frac{1}{2} \cdot 2 + \frac{\sqrt{3}}{2} \cdot 1
\end{pmatrix}
=
\begin{pmatrix}
\sqrt{3} - \frac{1}{2} \\
1 + \frac{\sqrt{3}}{2}
\end{pmatrix}
$$

"""



"""#### 2.6 ÐžÐ±'Ñ”Ð´Ð½Ð°Ð¹ Ð¿ÐµÑ€ÐµÑ‚Ð²Ð¾Ñ€ÐµÐ½Ð½Ñ Ð· ÐºÑ€Ð¾ÐºÑ–Ð² 1, 2, 4, 5 Ð² Ð¾Ð´Ð½Ñƒ Ð¼Ð°Ñ‚Ñ€Ð¸Ñ†ÑŽ Ñ‚Ð° Ð·Ð°ÑÑ‚Ð¾ÑÑƒÐ¹ Ñ—Ñ— Ð´Ð¾ Ð²ÐµÐºÑ‚Ð¾Ñ€Ñƒ $x$.

$$
M_6 = M_5 \cdot M_4 \cdot M_2 \cdot M_1 = ?
$$

$$
M_6 =
\begin{pmatrix}
\sqrt{3} - \frac{1}{2} \\
1 + \frac{\sqrt{3}}{2}
\end{pmatrix}
\cdot
\begin{pmatrix}
1 - \frac{\sqrt{3}}{2} \\
\sqrt{3} + \frac{1}{2}
\end{pmatrix}
\cdot
\begin{pmatrix}
-2 \\
-1
\end{pmatrix}
\cdot
\begin{pmatrix}
1 \\
3
\end{pmatrix}
M_6 = 2\sqrt{3} - \frac{7}{2}
$$
"""



"""# Ð—Ð°Ð²Ð´Ð°Ð½Ð½Ñ 2 (ÐÐ»ÑŒÑ‚ÐµÑ€Ð½Ð°Ñ‚Ð¸Ð²Ð½Ðµ)"""

!pip install cairosvg

import cv2 as cv
import urllib.request
import numpy as np
from google.colab.patches import cv2_imshow as cv_imshow
import cairosvg

def read_svg_image_by_url(url):
    try:
        # Use a context manager to handle the URL request
        with urllib.request.urlopen(url) as req:
            svg_data = req.read()

        # Convert SVG data directly to PNG bytes using cairosvg
        png_data = cairosvg.svg2png(bytestring=svg_data)

        # Decode the PNG bytes directly into an OpenCV image
        nparr = np.frombuffer(png_data, np.uint8)
        img = cv.imdecode(nparr, cv.IMREAD_COLOR)
        return img

    except Exception as e:
        print(f"ÐŸÐ¾Ð¼Ð¸Ð»ÐºÐ° Ð¿Ñ€Ð¸ Ð·Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶ÐµÐ½Ð½Ñ– Ð°Ð±Ð¾ Ð¾Ð±Ñ€Ð¾Ð±Ñ†Ñ– Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð½Ñ: {e}")
        return None

url = 'https://raw.githubusercontent.com/devicons/devicon/master/icons/javascript/javascript-original.svg'

img = read_svg_image_by_url(url)

if img is not None:
    cv_imshow(img)
else:
    print("ÐÐµÐ¼Ð¾Ð¶Ð»Ð¸Ð²Ð¾ Ð·Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶Ð¸Ñ‚Ð¸ Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð½Ñ.")

import cv2 as cv
import numpy as np
from google.colab.patches import cv2_imshow as cv_imshow

def rotate_and_scale_image_manual(image, angle_degrees, scale_x, scale_y):
    # Get image dimensions
    height, width = image.shape[:2]

    # Convert angle from degrees to radians
    angle_radians = np.deg2rad(angle_degrees)

    # Calculate the center of the image
    center_x, center_y = width / 2, height / 2

    # Create the rotation matrix manually
    cos_theta = np.cos(angle_radians)
    sin_theta = np.sin(angle_radians)

    # Construct the rotation matrix around the image center
    rotation_matrix = np.array([
        [cos_theta, -sin_theta, (1 - cos_theta) * center_x + sin_theta * center_y],
        [sin_theta, cos_theta, (1 - cos_theta) * center_y - sin_theta * center_x],
        [0, 0, 1]
    ], dtype=np.float32)

    # Create the scaling matrix
    scaling_matrix = np.array([
        [scale_x, 0, center_x * (1 - scale_x)],
        [0, scale_y, center_y * (1 - scale_y)],
        [0, 0, 1]
    ], dtype=np.float32)

    # Combine the rotation and scaling matrices
    transformation_matrix = np.dot(rotation_matrix, scaling_matrix)

    # Apply the perspective transformation
    transformed_image = cv.warpPerspective(image, transformation_matrix, (width, height))

    return transformed_image

# Example usage:
# Assume 'img' is your input image loaded via OpenCV

# Rotate and scale the image
rotated_scaled_img = rotate_and_scale_image_manual(img, angle_degrees=30, scale_x=0.5, scale_y=0.33)

# Display the transformed image
cv_imshow(rotated_scaled_img)

import cv2 as cv
import numpy as np
from google.colab.patches import cv2_imshow
import urllib.request
import cairosvg

def read_svg_image_by_url(url):
    try:
        with urllib.request.urlopen(url) as req:
            svg_data = req.read()

        # Convert SVG data directly to PNG bytes using cairosvg
        png_data = cairosvg.svg2png(bytestring=svg_data)

        # Decode the PNG bytes directly into an OpenCV image
        nparr = np.frombuffer(png_data, np.uint8)
        img = cv.imdecode(nparr, cv.IMREAD_COLOR)
        return img

    except Exception as e:
        print(f"Error while loading or processing the image: {e}")
        return None

def rotate_image_around_y_axis(image, angle_degrees):
    # Convert angle from degrees to radians
    angle_radians = np.deg2rad(angle_degrees)

    # Get image dimensions
    h, w = image.shape[:2]

    # Calculate focal length (adjust as needed)
    f = w / (2.0 * np.tan(np.deg2rad(45) / 2))

    # Projection matrix 2D -> 3D
    A1 = np.array([
        [1, 0, -w / 2],
        [0, 1, -h / 2],
        [0, 0, 0],
        [0, 0, 1]
    ])

    # Rotation matrix around Y-axis
    R = np.array([
        [np.cos(angle_radians), 0, np.sin(angle_radians), 0],
        [0, 1, 0, 0],
        [-np.sin(angle_radians), 0, np.cos(angle_radians), 0],
        [0, 0, 0, 1]
    ])

    # Translation matrix (no translation)
    T = np.array([
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, f],
        [0, 0, 0, 1]
    ])

    # Projection matrix 3D -> 2D
    A2 = np.array([
        [f, 0, w / 2, 0],
        [0, f, h / 2, 0],
        [0, 0, 1, 0]
    ])

    # Combined transformation matrix
    trans = A2 @ T @ R @ A1

    # Apply perspective warp
    transformed_image = cv.warpPerspective(image, trans, (w, h))

    return transformed_image

# URL of the SVG image
svg_url = 'https://raw.githubusercontent.com/devicons/devicon/master/icons/javascript/javascript-original.svg'

# Load SVG image from URL
img = read_svg_image_by_url(svg_url)

if img is None:
    print("Error: Unable to load image.")
else:
    # Rotate the image around Y-axis by 60 degrees
    rotated_img = rotate_image_around_y_axis(img, 60)

    # Display the transformed image
    cv_imshow(rotated_img)

import cv2 as cv
import numpy as np
from google.colab.patches import cv2_imshow as cv_imshow
import urllib.request
import io
from PIL import Image
import cairosvg

def scale_image_manual(image, scale_x, scale_y):
    # Get image dimensions
    height, width = image.shape[:2]

    # Calculate new dimensions
    new_width = int(width * scale_x)
    new_height = int(height * scale_y)

    # Calculate the center of the image
    center_x, center_y = width / 2, height / 2
    new_center_x, new_center_y = new_width / 2, new_height / 2

    # Create the scaling matrix in homogeneous coordinates
    scaling_matrix = np.array([
        [scale_x, 0, new_center_x - scale_x * center_x],
        [0, scale_y, new_center_y - scale_y * center_y],
        [0, 0, 1]
    ], dtype=np.float32)

    # Apply the perspective transformation with new dimensions
    transformed_image = cv.warpPerspective(image, scaling_matrix, (new_width, new_height))

    return transformed_image

# Install cairosvg if not already installed
try:
    import cairosvg
except ImportError:
    !pip install cairosvg
    import cairosvg

# Load your image from URL
image_url = 'https://raw.githubusercontent.com/devicons/devicon/master/icons/javascript/javascript-original.svg'

try:
    # Download the SVG data
    with urllib.request.urlopen(image_url) as response:
        svg_data = response.read()

    # Convert SVG data to PNG bytes using cairosvg
    png_data = cairosvg.svg2png(bytestring=svg_data)

    # Convert PNG bytes to OpenCV image
    nparr = np.frombuffer(png_data, np.uint8)
    img = cv.imdecode(nparr, cv.IMREAD_UNCHANGED)

except Exception as e:
    print(f"Error loading image: {e}")
    img = None

if img is not None:
    # Scale the image: Reduce by 2 times along OX and increase by 3 times along OY
    scaled_img = scale_image_manual(img, scale_x=0.5, scale_y=3.0)

    # Display the original and scaled images
    print("Original Image:")
    cv_imshow(img)
    print("Scaled Image:")
    cv_imshow(scaled_img)
else:
    print("Failed to load the image.")

import cv2 as cv
import numpy as np
from google.colab.patches import cv2_imshow as cv_imshow
import urllib.request
import io
from PIL import Image
import cairosvg

def reflect_image_origin(image):
    # Get image dimensions
    height, width = image.shape[:2]

    # Create the reflection matrix
    reflection_matrix = np.array([
        [-1,  0,  width],
        [ 0, -1, height],
        [ 0,  0,     1 ]
    ], dtype=np.float32)

    # Apply the perspective transformation
    reflected_image = cv.warpPerspective(image, reflection_matrix, (width, height))

    return reflected_image

# Load the image
import urllib.request

# Use a valid SVG image URL
image_url = 'https://raw.githubusercontent.com/devicons/devicon/master/icons/javascript/javascript-original.svg'

try:
    # Read the SVG image data from the URL
    with urllib.request.urlopen(image_url) as url:
        svg_data = url.read()

    # Convert SVG to PNG using cairosvg
    png_data = cairosvg.svg2png(bytestring=svg_data)

    # Convert the PNG data to a NumPy array
    png_array = np.frombuffer(png_data, dtype=np.uint8)

    # Decode the image using OpenCV
    image = cv.imdecode(png_array, cv.IMREAD_COLOR)

    # Check if the image was loaded successfully
    if image is None:
        print("Error: Could not decode the image.")
    else:
        # Reflect the image with respect to the origin
        reflected_img = reflect_image_origin(image)

        # Display the original and reflected images
        print("Original Image:")
        cv_imshow(image)            # Original image

        print("Reflected Image:")
        cv_imshow(reflected_img)    # Reflected image

except Exception as e:
    print(f"Error: {e}")

import cv2 as cv
import numpy as np
from google.colab.patches import cv2_imshow as cv_imshow
import urllib.request
import cairosvg

def read_svg_image_by_url(url):
    try:
        # Download the SVG image
        with urllib.request.urlopen(url) as req:
            svg_data = req.read()

        # Convert SVG to PNG bytes using cairosvg
        png_data = cairosvg.svg2png(bytestring=svg_data)

        # Decode the PNG bytes directly into an OpenCV image
        nparr = np.frombuffer(png_data, np.uint8)
        img = cv.imdecode(nparr, cv.IMREAD_UNCHANGED)
        return img

    except Exception as e:
        print(f"Error while loading or processing the image: {e}")
        return None

def translate_image(image, tx, ty):
    # Get image dimensions
    height, width = image.shape[:2]

    # Create the translation matrix
    translation_matrix = np.array([
        [1, 0, tx],
        [0, 1, ty]
    ], dtype=np.float32)

    # Apply the translation using warpAffine
    translated_image = cv.warpAffine(image, translation_matrix, (width, height))

    return translated_image

# URL of the SVG image
url = 'https://raw.githubusercontent.com/devicons/devicon/master/icons/javascript/javascript-original.svg'

# Read the SVG image from the URL
img = read_svg_image_by_url(url)

# Check if the image was loaded successfully
if img is not None:
    # Translate the image by -3 along OX and 1 along OY
    tx = -3  # Translation along the x-axis (OX)
    ty = 1   # Translation along the y-axis (OY)

    translated_img = translate_image(img, tx, ty)

    # Display the original and translated images
    cv_imshow(img)
    cv_imshow(translated_img)
else:
    print("Unable to load the image.")